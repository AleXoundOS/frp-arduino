-- Copyright (c) 2014 Contributors as noted in the AUTHORS file
--
-- This file is part of frp-arduino.
--
-- frp-arduino is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- frp-arduino is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with frp-arduino.  If not, see <http://www.gnu.org/licenses/>.

module Arduino.Internal.CodeGen where

import Control.Monad.State
import Data.List (intercalate, elemIndex)
import Data.Maybe (fromJust)
import qualified Data.Map as M

import Arduino.Internal.DAG
import CCodeGen

streamsToC :: Streams -> String
streamsToC = runGen . genStreamsCFile

genStreamsCFile :: Streams -> Gen ()
genStreamsCFile streams = do
    header "// This file is automatically generated."
    header ""
    header "#include <avr/io.h>"
    header "#include <stdbool.h>"
    mapM (genStreamCFunction streams) (streamsInTree streams)
    line ""
    block "int main(void) {" $ do
        mapM genInit (streamsInTree streams)
        block "while (1) {" $ do
            mapM genInputCall (streamsInTree streams)
        line "}"
        line "return 0;"
    line "}"

genStreamCFunction :: Streams -> Stream -> Gen ()
genStreamCFunction streams stream = do
    let args = streamArguments streams (name stream)
    let declaration = ("static void " ++ name stream ++
                       "(" ++ streamToArgumentList streams stream ++ ")")
    cFunction declaration $ do
        let t = streamCType streams (name stream)
        genStreamInputParsing args
        let inputTypes = map (streamCType streams) (inputs stream)
        let inputMap = M.fromList $ zip [0..] inputTypes
        outputNames <- genStreamBody (expressionCType inputMap) (body stream)
        genStreamOuputCalling outputNames streams stream

streamToArgumentList :: Streams -> Stream -> String
streamToArgumentList streams stream
    | length args <= 1 =
        intercalate ", " $ map (\(name, cType, _) -> (cType ++ " " ++ name)) args
    | otherwise =
        "int arg, void* value"
    where
        args = streamArguments streams (name stream)

streamArguments :: Streams -> String -> [(String, String, Int)]
streamArguments streams streamName =
    map (\(input, cType) -> ("input_" ++ show input, cType, input)) $
    zip [0..] $
    map (streamCType streams) $
    inputs $
    streamFromId streams streamName

genStreamInputParsing :: [(String, String, Int)] -> Gen ()
genStreamInputParsing args = do
    when ((length args) > 1) $ do
        forM_ args $ \(name, cType, _) -> do
            line $ "static " ++ cType ++ " " ++ name ++ ";"
        block "switch (arg) {" $ do
            forM_ args $ \(name, cType, n) -> do
                block ("case " ++ show n ++ ":") $ do
                    line $ name ++ " = *((" ++ cType ++ "*)value);"
                    line $ "break;"
        line $ "}"

streamCType :: Streams -> String -> String
streamCType streams streamName = case body stream of
    (Driver _ bodyLLI)     -> lliCType bodyLLI
    (Builtin "clock")      -> "unsigned int"
    (Transform expression) -> expressionCType inputMap expression
    where
        inputMap = M.fromList $ zip [0..] inputTypes
        inputTypes = map (streamCType streams) (inputs stream)
        stream = streamFromId streams streamName

expressionCType :: M.Map Int String -> Expression -> String
expressionCType inputMap expression = case expression of
    (Input x)        -> fromJust $ M.lookup x inputMap
    (Not _)          -> "bool"
    (Even _)         -> "bool"
    (CharConstant _) -> "char"
    (BoolConstant _) -> "bool"
    (Many (x:_))     -> expressionCType inputMap x
    (If _ _ x)       -> expressionCType inputMap x

genStreamBody :: (Expression -> String) -> Body -> Gen [String]
genStreamBody expressionCType body = case body of
    (Driver _ bodyLLI)     -> genLLI bodyLLI
    (Transform expression) -> do
        genExpression expressionCType expression
    (Builtin "clock") -> do
        temp <- label
        line $ "static unsigned int " ++ temp ++ " = 0U;"
        line $ temp ++ "++;"
        return [temp]

genStreamOuputCalling :: [Identifier] -> Streams -> Stream -> Gen ()
genStreamOuputCalling outputNames streams stream = do
    forM_ outputNames $ \outputName -> do
    forM_ (outputs stream) $ \x -> do
        if (length (inputs (streamFromId streams x))) > 1
            then do
                let n = fromJust $ elemIndex (name stream) (inputs (streamFromId streams x))
                line (x ++ "(" ++ show n ++ ", (void*)(&" ++ outputName ++ "));")
            else do
                line (x ++ "(" ++ outputName ++ ");")

genExpression :: (Expression -> String) -> Expression -> Gen [String]
genExpression expressionCType expression = case expression of
    (Not expression) -> do
        [inner] <- genExpression expressionCType expression
        wrap ("!(" ++ inner ++ ")")
    (Even expression) -> do
        [inner] <- genExpression expressionCType expression
        wrap ("(" ++ inner ++ ") % 2 == 0")
    (Input value) -> do
        return ["input_" ++ show value]
    (CharConstant value) -> do
        return [show value]
    (BoolConstant value) -> do
        if value
            then (wrap "true")
            else (wrap "false")
    (If conditionExpression trueExpression falseExpression) -> do
        temp <- var (expressionCType falseExpression)
        [conditionResult] <- genExpression expressionCType conditionExpression
        [trueResult] <- genExpression expressionCType trueExpression
        [falseResult] <- genExpression expressionCType falseExpression
        block ("if (" ++ conditionResult ++ ") {") $ do
            line $ temp ++ " = " ++ trueResult ++ ";"
        block "} else {" $ do
            line $ temp ++ " = " ++ falseResult ++ ";"
        line $ "}"
        return [temp]
    (Many values) -> do
        mapM (\x -> genExpression expressionCType x >>= \[y] -> return y) values
    where
        wrap e = do
            name <- var (expressionCType expression)
            line $ name ++ " = " ++ e ++ ";"
            return [name]

genInit :: Stream -> Gen ()
genInit stream = case body stream of
    (Driver initLLI _) -> genLLI initLLI >> return ()
    (Builtin "clock")  -> do
        line $ "TCCR1B = (1 << CS12) | (1 << CS10);"
    _ -> do
        return ()

genInputCall :: Stream -> Gen ()
genInputCall stream = case body stream of
    (Builtin "clock") -> do
        block "if (TCNT1 >= 10000) {" $ do
            line "TCNT1 = 0;"
            line "clock();"
        line "}"
    _ -> do
        when (length (inputs stream) == 0) $ do
            line (name stream ++ "();")

genLLI :: LLI -> Gen [String]
genLLI lli = case lli of
    (WriteBit register bit value next) ->
        case value of
            High -> do
                line (register ++ " |= (1 << " ++ bit ++ ");")
                genLLI next
            Low -> do
                line (register ++ " &= ~(1 << " ++ bit ++ ");")
                genLLI next
    (WriteByte register value next) -> do
        line (register ++ " = " ++ value ++ ";")
        genLLI next
    (ReadBit register bit) -> do
        x <- var "bool"
        line $ x ++ " = (" ++ register ++ " & (1 << " ++ bit ++ ")) == 0U;"
        return [x]
    (WaitBit register bit value next) -> do
        case value of
            High -> do
                line $ "while ((" ++ register ++ " & (1 << " ++ bit ++ ")) == 0) {"
                line $ "}"
        genLLI next
    (Switch name t f next) -> do
        block "if (input_0) {" $ do
            genLLI t
        block "} else {" $ do
            genLLI f
        line "}"
        genLLI next
    End -> do
        return []

lliCType :: LLI -> String
lliCType (WriteBit _ _ _ next) = lliCType next
lliCType (Switch _ _ _ next)   = lliCType next
lliCType (ReadBit _ _)         = "bool"
lliCType End                   = "void"
